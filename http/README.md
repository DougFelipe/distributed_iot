# üåê **PROTOCOLO HTTP - SISTEMA IoT DISTRIBU√çDO**

**Comunica√ß√£o HTTP/1.1 para Testes, Integra√ß√£o e Desenvolvimento**

---

## üìã **√çNDICE**

1. [Por que HTTP no Sistema IoT?](#1-por-que-http)
2. [Arquitetura e Design](#2-arquitetura-e-design)
3. [Como Funciona na Pr√°tica](#3-como-funciona)
4. [Integra√ß√£o com JMeter](#4-integra√ß√£o-jmeter)
5. [Sensores Virtuais HTTP](#5-sensores-virtuais)
6. [Data Receivers e Persist√™ncia](#6-data-receivers)
7. [Version Vector via HTTP](#7-version-vector)
8. [Performance e Limita√ß√µes](#8-performance)

---

## 1. **POR QUE HTTP?**

### üéØ **O Problema que Resolvemos**

Imagine que voc√™ tem um sistema IoT funcionando perfeitamente com UDP, mas precisa test√°-lo com JMeter para avaliar performance sob carga. O problema √© que o JMeter foi projetado para trabalhar com HTTP, n√£o com UDP.

**A solu√ß√£o:** Criar uma camada HTTP que funciona como uma "ponte" para o sistema UDP existente. Assim, o JMeter pode enviar requisi√ß√µes HTTP normais, que s√£o convertidas internamente para o formato IoT e processadas pelo mesmo motor que processa mensagens UDP.

### üîÑ **Benef√≠cios Pr√°ticos**

**Para Desenvolvimento:**
- Debug mais f√°cil com navegadores e Postman
- Logs leg√≠veis em formato JSON
- Ferramentas de rede padr√£o funcionam

**Para Testes:**
- JMeter pode simular milhares de sensores
- Medi√ß√£o precisa de lat√™ncia e throughput
- Relat√≥rios de performance autom√°ticos

**Para Integra√ß√£o:**
- APIs REST para sistemas externos
- Health checks para monitoramento
- CORS habilitado para aplica√ß√µes web

### ü§î **HTTP vs UDP: Quando Usar Cada Um?**

**Use HTTP quando:**
- Estiver testando com JMeter ou ferramentas similares
- Precisar debugar problemas (JSON √© leg√≠vel)
- Integrar com sistemas web existentes
- Desenvolver e prototipar rapidamente
- Atravessar firewalls corporativos

**Use UDP quando:**
- Performance for cr√≠tica (sistemas de produ√ß√£o)
- Trabalhar com dispositivos embarcados
- Precisar de baix√≠ssima lat√™ncia
- Enviar milhares de mensagens por segundo
- Implementar multicast/broadcast

**A Beleza do Strategy Pattern:**
O sistema permite trocar entre HTTP e UDP **sem alterar uma linha** da l√≥gica de neg√≥cio. O Gateway IoT, os Data Receivers, e todo o sistema de Version Vector funcionam exatamente igual nos dois protocolos.

---

## 2. **ARQUITETURA E DESIGN**

### üèóÔ∏è **A Grande Ideia: Adapter Pattern**

O sistema HTTP funciona como um **adaptador** entre o mundo HTTP (JMeter, browsers, APIs) and o mundo IoT interno. √â como ter um tradutor que fala HTTP com o cliente e IoT com o sistema interno.

**Fluxo Conceitual:**
1. **Cliente HTTP** envia POST /sensor/data com JSON
2. **HTTP Adapter** recebe e converte para IoTMessage  
3. **Gateway IoT** processa como se fosse UDP
4. **Data Receivers** armazenam normalmente
5. **HTTP Adapter** converte resposta para JSON
6. **Cliente HTTP** recebe status de sucesso

### üé≠ **Strategy Pattern em A√ß√£o**

O sistema implementa o Strategy Pattern, permitindo trocar protocolos dinamicamente:

- **Interface CommunicationStrategy:** Define o contrato comum
- **HTTPCommunicationStrategy:** Implementa√ß√£o HTTP
- **UDPCommunicationStrategy:** Implementa√ß√£o UDP  
- **IoTGateway:** Usa qualquer strategy transparentemente

**Benef√≠cio:** Adicionar um novo protocolo (TCP, gRPC, WebSocket) significa apenas criar uma nova Strategy, sem tocar no core do sistema.

### üßµ **Threading e Concorr√™ncia**

**O Desafio:** Como processar centenas de requisi√ß√µes HTTP simult√¢neas sem travar?

**A Solu√ß√£o:** Thread Pool com arquitetura producer-consumer:
- **Main Thread:** Aceita conex√µes (ServerSocket.accept())
- **Thread Pool:** Processa cada conex√£o em thread separada
- **Worker Threads:** HTTPClientHandler processa uma requisi√ß√£o por vez

**Configura√ß√£o Padr√£o:**
- 50 threads no pool (ajust√°vel)
- 300 conex√µes no backlog
- Timeout autom√°tico para conex√µes penduradas

---

## 3. **COMO FUNCIONA NA PR√ÅTICA**

### ÔøΩ **O Ciclo de Vida de uma Requisi√ß√£o**

Vamos acompanhar o que acontece quando o JMeter envia uma requisi√ß√£o HTTP:

**1. Chegada da Requisi√ß√£o:**
O JMeter envia um POST para `http://localhost:8081/sensor/data` com JSON contendo dados do sensor. O servidor HTTP est√° escutando na porta 8081 e imediatamente aceita a conex√£o.

**2. Delega√ß√£o para Thread Pool:**
O servidor n√£o processa a requisi√ß√£o na thread principal (isso travaria outras conex√µes). Em vez disso, cria um HTTPClientHandler e envia para o thread pool processar.

**3. Parsing HTTP ‚Üí IoT:**
O HTTPClientHandler faz o trabalho pesado:
- L√™ headers HTTP line-by-line
- Extrai o corpo JSON da requisi√ß√£o  
- Converte JSON para objeto IoTMessage
- Valida se todos os campos obrigat√≥rios est√£o presentes

**4. Integra√ß√£o com Gateway:**
Aqui est√° a m√°gica! O HTTPClientHandler entrega o IoTMessage para o mesmo Gateway que processa mensagens UDP. O Gateway n√£o sabe (nem precisa saber) se a mensagem veio via HTTP ou UDP.

**5. Resposta HTTP:**
Ap√≥s o processamento, o sistema constr√≥i uma resposta JSON com status de sucesso, ID da mensagem processada, e o Version Vector atualizado. Tudo formatado seguindo padr√µes HTTP/1.1.

### ‚öôÔ∏è **Configura√ß√µes Avan√ßadas**

```java
/**
 * BUILDER PATTERN para configura√ß√µes HTTP
 */
public class HTTPCommunicationStrategy implements CommunicationStrategy {
    
    /**
     * Configurar tamanho do thread pool
     */
    public void setThreadPoolSize(int size) {
        if (running.get()) {
            throw new IllegalStateException("N√£o √© poss√≠vel alterar thread pool com servidor rodando");
        }
        
        if (threadPool != null && !threadPool.isShutdown()) {
            threadPool.shutdown();
        }
        
        this.threadPool = Executors.newFixedThreadPool(size);
        System.out.println("üåê Thread pool HTTP configurado para " + size + " threads");
    }
    
    /**
     * VIRTUAL THREADS support (Java 21+)
     */
    public void enableVirtualThreads() {
        if (running.get()) {
            throw new IllegalStateException("N√£o √© poss√≠vel alterar thread pool com servidor rodando");
        }
        
        try {
            // Tentar criar ExecutorService com virtual threads
            this.threadPool = Executors.newVirtualThreadPerTaskExecutor();
            System.out.println("üåê Virtual threads habilitadas para HTTP Strategy");
        } catch (Exception e) {
            System.out.println("‚ö†Ô∏è Virtual threads n√£o dispon√≠veis, usando thread pool tradicional");
            this.threadPool = Executors.newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE);
        }
    }
    
    /**
     * Gateway Integration
     */
    public void setGateway(IoTGateway gateway) {
        this.gateway = gateway;
    }
}
```

---

## 3. **STRATEGY PATTERN**

### üéØ **Interface CommunicationStrategy**

```java
/**
 * Strategy Pattern - Interface para protocolos de comunica√ß√£o
 */
public interface CommunicationStrategy {
    
    /**
     * Inicia o servidor/listener para este protocolo
     */
    void startServer(int port) throws Exception;
    
    /**
     * Para o servidor/listener
     */
    void stopServer();
    
    /**
     * Envia mensagem IoT (cliente)
     */
    boolean sendMessage(IoTMessage message, String host, int port);
    
    /**
     * Processa mensagem IoT recebida
     */
    void processMessage(IoTMessage message, String senderHost, int senderPort);
    
    /**
     * Nome do protocolo
     */
    String getProtocolName();
    
    /**
     * Status do servidor
     */
    boolean isRunning();
}
```

### üîÑ **HTTP Strategy Implementation**

```java
/**
 * Implementa√ß√£o HTTP do Strategy Pattern
 */
public class HTTPCommunicationStrategy implements CommunicationStrategy {
    
    @Override
    public void startServer(int port) throws Exception {
        if (running.get()) {
            throw new IllegalStateException("HTTP Server j√° est√° rodando na porta " + this.port);
        }
        
        this.port = port;
        
        try {
            serverSocket = new ServerSocket(port, DEFAULT_BACKLOG);
            running.set(true);
            
            System.out.println("üåê HTTP Strategy Server iniciado na porta " + port);
            System.out.println("üåê Aguardando conex√µes HTTP para IoT Gateway...");
            
            // ASYNC ACCEPT LOOP - Non-blocking
            threadPool.submit(() -> {
                while (running.get() && !serverSocket.isClosed()) {
                    try {
                        Socket clientSocket = serverSocket.accept();
                        
                        if (!running.get()) {
                            clientSocket.close();
                            break;
                        }
                        
                        System.out.println("üåê Nova conex√£o HTTP de " + 
                                         clientSocket.getRemoteSocketAddress());
                        
                        // DELEGATION PATTERN - Handler processing
                        HTTPClientHandler handler = new HTTPClientHandler(clientSocket, gateway);
                        threadPool.execute(handler);
                        
                    } catch (IOException e) {
                        if (running.get()) {
                            System.err.println("‚ùå Erro ao aceitar conex√£o HTTP: " + e.getMessage());
                        }
                    }
                }
            });
            
        } catch (IOException e) {
            running.set(false);
            System.err.println("‚ùå Erro ao iniciar HTTP Strategy Server: " + e.getMessage());
            throw new Exception("Falha ao iniciar servidor HTTP na porta " + port, e);
        }
    }
    
    @Override
    public String getProtocolName() {
        return "HTTP/1.1";
    }
    
    @Override
    public boolean sendMessage(IoTMessage message, String targetAddress, int targetPort) {
        // HTTP √© principalmente server-side para este sistema IoT
        // Cliente HTTP seria implementado se necess√°rio para comunica√ß√£o externa
        System.out.println("‚ö†Ô∏è sendMessage n√£o implementado para HTTP Strategy (server-only)");
        return false;
    }
}
```

---

**üìù Documenta√ß√£o HTTP criada por:** UFRN-DIMAP  
**üìÖ Data:** 30 de Setembro de 2025  
**üîñ Vers√£o:** 1.0 - Parte 1  
**üéØ Foco:** Vis√£o Geral, Arquitetura e Strategy Pattern